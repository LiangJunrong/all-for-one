##面向对象02

<img src="./assets/logo.png"  />

### 本节知识点

-   工厂模式及自定义事件

-  抽离英雄基类
-  抽离技能基类
-  扩展皮肤类
- 单例模式使用
-  装饰者模式使用

### 课堂目标

- 学会各种设计模式的使用
- 学会面向对象中抽象使用
- 理解类中的继承
- oop思想规划项目

### 案例内容扩展

- 扩展皮肤功能

- 抽离英雄基类
  - 每个英雄的共有属性
  - 共有方法及独特方法
- 抽离技能基类

## 设计模式

​		设计模式是软件开发人员在软件开发过程中面临的一些具有代表性问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的；

## 单例模式

- **单例模式** （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。

  - 通过静态属性创建单例

    ```js
    class Person{
        static instance = null;
        constructor(name){
            if(Person.instance){
                return Person.instance;
            }
            Person.instance = this;
            this.name = name;
        }
    }
    
    ```

  - 通过函数创建单例

    ```js
    let instance;
    function createInstance(...arg){
        if(!instance){
            instance = new Game(...arg);
        }
        return instance;
    }
    ```

  - 实现game类的单例

    - 优：单例模式节约内存开支和实例化时的性能开支，节约性能；
    - 缺：单例模式扩展性不强

## 工厂模式

-  **工厂模式** （Factory Pattern），封装具体实例创建逻辑和过程，外部只需要根据不同条件返回不同的实例。
  - 优点：实现代码复用性，封装良好，抽象逻辑；
  - 缺点：增加了代码复杂程度；

## 装饰者模式

-  **装饰者模式** （Decorator Pattern）使用一种更为灵活的方式来动态给一个对象/函数等添加额外信息
  - 扩展功能 和继承类似
  - 扩展不同类的功能，和原始类并无关联；



## 观察者模式（自定义事件）

-  **观察者模式** （Observer Pattern） 定义一个对象与其他对象之间的一种依赖关系，当对象发生某种变化的时候，依赖它的其它对象都会得到更新
  - 自定义事件绑定addEvent
  - 自定义事件触发trigger
  - 自定义事件移除removeEvent
- 实现案例GameEvent类

## 课程总结

-   工厂模式及观察者模式

-  抽离英雄基类
-  抽离技能基类
-  扩展皮肤类
- 单例模式使用
-  装饰者模式使用

## 下节预告

- 面向对象03

  

